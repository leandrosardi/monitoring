<%
# TODO: Move this to config.rb when I can deploy with '"'
# Defining monitors
BlackStack::Monitoring.remove_all
BlackStack::Monitoring.set([{
# Total Resources
# - scrapers online - total
# - addresses shared - total
# Capacity
# - daily pages upload capacity (achieved / needed)
# - daily email deliveries capacity (achieved / needed)
# Performance
# - average scrapers performance (uploaded pages / daily quota)
# - pages upload / hr. (achieved / needed)
# - pages earning / hr. (achieved / needed)
# - pages parsing / hr. (achieved / needed)
# - average emails appened / page (achieved / needed)
# - emails delivery / hr. (achieved / needed)
# Errors
# - page.upload error rate
# - page.earning error rate
# - page.parsing error rate
# - email.delivery error rate

# Total Resources
# - how many scrapers are online
# - how many addresses are shared and able to deliver
  :section_name => '1. Total Resources',
  :name => 'Scrapers (Last Hour)',
  :description => 'Number of Scrpers Sharing their Extensions and Active the Last Hour',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
      select count(*) as n
      from '+34.chr+'user'+34.chr+' u
      where coalesce(u.scraper_share, false) = true
      and u.scraper_last_ping_time > cast(\''+now.to_s+'\' as timestamp) - interval \'1 hours\'
    '
    DB[q].first[:n].to_i
  end,
  :threshold => nil, # there is no threshold to comparate
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'scrapers',
}, {
  :section_name => '1. Total Resources',
  :name => 'Addresses',
  :description => 'Number of Addresses, Shared and Enabled, that Passed the Last Check',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
    select count(a.*) as n
    from eml_address a
    where coalesce(a.shared, false) = true
    and coalesce(a.enabled, false) = true
    and coalesce(a.check_success, false) = true
    '
    DB[q].first[:n].to_i
  end,
  :threshold => nil, # there is no threshold to comparate
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'addresses',

# Capacity
# capacity: to know if I have resources enough to handle the current clientelle
}, {
  :section_name => '2. Capacity',
  :name => 'Page Uploading Capacity',
  :description => 'Daily pages upload (capacity / needed)<br/><a target="_window" href="https://github.com/leandrosardi/cs/issues/22">Problem Resolution Procedure</a>.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select 'daily pages upload capacity', sum(u.stealth_default_max_pages_per_day) as n
    from \"user\" u
    where coalesce(u.scraper_last_ping_time, '2000-01-01') > current_timestamp - interval '1 day' 
    and coalesce(u.scraper_share, false) = true 
    and coalesce(u.scraper_enabled, false) = true    
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = "
    select 'daily pages upload needed', sum(v.pages_per_day) as n 
    from v_dfyl_capacity_needed v 
    where v.pages_per_day > 0        
    "
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'pages uploaded',
}, {
  :section_name => '2. Capacity',
  :name => 'Emails Delivering Capacity',
  :description => 'daily email deliveries (capacity / needed)<br/><a target="_window" href="https://github.com/leandrosardi/cs/issues/22">Problem Resolution Procedure</a>.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select 'daily emails delivery capacity', sum(a.max_deliveries_per_day) as n
    from eml_address a
    where a.delete_time is null
    and a.shared = true
    and a.enabled = true    
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = "
    select 'daily pages upload needed', cast(sum(v.email_credits) as float)/28 as n 
    from v_eml_deadlines v 
    where v.email_credits > 0    
    "
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'emails deliveried',

# Under-performing
# under-performing: to know if I all resources are running at all their capacity
}, {
  :section_name => '3. Under-Performing',
  :name => 'Page Uploading Under-Performing',
  :description => 'Daily pages upload under-performing (achieved / needed)<br/><a target="_window" href="https://github.com/leandrosardi/cs/issues/22">Problem Resolution Procedure</a>.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select 'pages uploaded last day', count(distinct a.id_page) as n
    from scr_assignation a
    where a.create_time > current_timestamp - interval '1 day'
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = "
    select 'daily pages upload needed', sum(v.pages_per_day) as n
    from v_dfyl_capacity_needed v 
    where v.pages_per_day > 0
    "
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'pages uploaded',
}, {
  :section_name => '3. Under-Performing',
  :name => 'Emails Delivering Under-Performing',
  :description => 'daily email deliveries under-performing (achieved / needed)<br/><a target="_window" href="https://github.com/leandrosardi/cs/issues/22">Problem Resolution Procedure</a>.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select 'emails delivered last day', count(distinct d.id_lead) as n
    from eml_delivery d
    where d.create_time > current_timestamp - interval '1 day'
    and coalesce(d.delivery_success, false) = true
    and coalesce(d.is_response, false) = false
    and coalesce(d.is_bounce, false) = false
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = "
    select 'daily pages upload needed', cast(sum(v.email_credits) as float)/28 as n 
    from v_eml_deadlines v 
    where v.email_credits > 0
    "
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'emails deliveried',

# Queues
# queues: to detect when many tasks are getting stuck, and pending for processing.

# Failures
# failures: to detect when many tasks are getting failed recurrently.

# IPN
}, {
  :section_name => '4. Queue',
  :name => 'i2p.ipn',
  :description => 'IPNs pending for processing.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as n
    from buffer_paypal_notification b
    where b.sync_end_time is null
    and coalesce(b.sync_reservation_times, 0) < 3 
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'IPNs',
}, {
  :section_name => '4. Queue',
  :name => 'i2p.baddebt',
  :description => 'Payments processing failures with active subscriptions.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as n
    from (
      select b.subscr_id, count(b.id) as n, max(b.create_time) as last_ipn
      from buffer_paypal_notification b 
      join \"subscription\" s on (s.subscr_id=b.subscr_id and coalesce(s.active,false)=true) 
      where b.txn_type='subscr_failed' 
      group by b.subscr_id
      having max(b.create_time) < current_timestamp - interval '6 days'
    )
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'IPNs',
}, {
  :section_name => '4. Queue',
  :name => 'i2p.movement',
  :description => 'Accounts who did not update their balance snapshot in the last hour.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as m
    from account a 
    where coalesce(update_balance_end_time, '2000-01-01') < current_timestamp - interval '2 hours'
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Accounts',


}, {
  :section_name => '5. Failures',
  :name => 'i2p.ipn',
  :description => 'IPNs failed.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as n
    from buffer_paypal_notification b
    where b.sync_end_time is null
    and coalesce(b.sync_reservation_times, 0) >= 3 
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'IPNs',
}, {
  :section_name => '5. Failures',
  :name => 'i2p.movement',
  :description => 'Accounts who did not update their balance because of any glitch.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as m
    from account a 
    where coalesce(update_balance_success, false) = false
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Accounts',

# Leads
}, {
  :section_name => '4. Queue',
  :name => 'leads.export',
  :description => 'Export lists pending to be updated.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    SELECT count(DISTINCT e.id) as n
    FROM fl_export e
    JOIN fl_export_lead el ON ( el.id_export = e.id AND el.create_time > e.create_file_end_time )
    -- not deleted
    WHERE e.delete_time IS NULL
    -- not archived
    and e.delete_time is null
    and e.archive_success is null
    and e.archive_start_time is null
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Exports',

}, {
  :section_name => '5. Failures',
  :name => 'leads.export',
  :description => 'Export lists failed when being updated.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    SELECT count(DISTINCT e.id) as n
    FROM fl_export e
    -- not deleted
    WHERE e.delete_time IS NULL
    -- not archived
    and e.delete_time is null
    and e.archive_success is null
    and e.archive_start_time is null
    -- failed
    and coalesce(e.create_file_success, false) = false    
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Exports',

# Emails
}, {
  :section_name => '4. Queue',
  :name => 'emails.data.verify',
  :description => 'Data records pending to be verified.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as n
    from fl_data b
    where coalesce(b.verify_success, false) = false
    and coalesce(b.verify_reservation_times, 0) < 3 
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    10
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Data Records',
}, {
  :section_name => '5. Failures',
  :name => 'emails.data.verify',
  :description => 'Data records failed when being verified.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = "
    select count(*) as n
    from fl_data b
    where coalesce(b.verify_success, false) = false
    and coalesce(b.verify_reservation_times, 0) >= 3 
    "
    DB[q].first[:n].to_i
  end,
  :threshold_function => nil,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'Data Records',


=begin
}, {
  :section_name => '3. Performance',
  :name => 'Pages Upload / Hr.',
  :description => 'Number of Pages Uploaded the Last Hour',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
      --
      -- pages scraped in last hour - total
      select count(distinct p.id) as n
      from scr_page p
      where p.upload_end_time > cast(\''+now.to_s+'\' as timestamp) - interval \'1 hour\'
      and p.upload_success = true
    '
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = '
      -- pages upload needed per hour
      select -(coalesce(sum(b.credits),0) / (21*24)) / 10 as n
      from account a
      join balance b on (a.id=b.id_account and b.service_code=\'leads\')
    '
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'pages',
}, {
  :section_name => '3. Performance',
  :name => 'Pages Parsing / Hr.',
  :description => 'Number of Pages Parsed the Last Hour',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
      --
      -- pages scraped in last hour - total
      select count(distinct p.id) as n
      from scr_page p
      where p.parse_end_time > cast(\''+now.to_s+'\' as timestamp) - interval \'1 hour\'
      and p.parse_success = true
    '
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = '
      -- pages upload needed per hour
      select -(coalesce(sum(b.credits),0) / (21*24)) / 10 as n
      from account a
      join balance b on (a.id=b.id_account and b.service_code=\'leads\')
    '
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'pages',
}, {
  :section_name => '3. Performance',
  :name => 'Pages in Queue',
  :description => 'Number of Pages Pending to Be Parsed.\nKeep this number as low as possible, in order to pay additional for scraping services.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
      select count(distinct p.id) as n
      from scr_page p
      join scr_order o on (o.id=p.id_order and o.status=true)
      join '+34.chr+'user'+34.chr+' u on u.id=o.id_user
      join account a on a.id=u.id_account
      join balance b on (a.id=b.id_account and b.service_code=\'leads\' and b.amount>0)
      where p.parse_success is null
    '
    DB[q].first[:n].to_i
  end,
  :threshold => 0,
  :comparsion => BlackStack::Monitoring::COMPARSION_LESS_EQUAL,
  :unit_name => 'pages',
}, {
  :section_name => '3. Performance',
  :name => 'Email Delivery Capacity',
  :description => 'Number of Daily Emails that can be sent, over the number of daily emails I need to send.',
  :type => BlackStack::Monitoring::TYPE_INT,
  :value_function => Proc.new do |*args|
    q = '
      select sum(a.max_deliveries_per_day) as n
      from eml_address a
      where a.delete_time is null
      and a.shared = true
      and a.enabled = true
    '
    DB[q].first[:n].to_i
  end,
  :threshold_function => Proc.new do |*args|
    q = '
      select -(coalesce(sum(b.credits),0) / 21) as n
      from account a
      join balance b on (a.id=b.id_account and b.service_code=\'deliveries\')
    '
    DB[q].first[:n].to_i
  end,
  :comparsion => BlackStack::Monitoring::COMPARSION_GREATER,
  :unit_name => 'emails',
=end
}])
%>

<style>
    .legendLabel {
        color:White;
    }

	table.qabot {
		width:100%;
		margin-top:15px;
		padding-top:15px;
	}

	table.qabot tr.qarow {
		width:100%;
	}

	table.qabot tr.qarow td.qaname {
		width: 350px;
		font-size: 14px;
		border-bottom: 0px;
        color: gray;
	}

	table.qabot tr.qarow td.qaname span.qatitle {
		width: 350px;
		font-size: 14px;
		font-weight: bold;
		border-bottom: 0px;
        color: black;
	}

	table.qabot tr.qarow td.qadesc {
		width: auto;
		font-size: 10px;
		border-bottom: 2px solid #ccc;
	}

	table.qabot tr.qarow td.qaflag {
		width: 125px;
		height: 50px;
		text-align: center;
		vertical-align: middle;
		border-bottom: 2px solid #ccc;
	}

	table.qabot tr.qarow td.qaflag span.qavalue {
		height: 35px;
		font-size: 20px;
		font-weight: bold;
	}

	table.qabot tr.qarow td.qaflag span.qacomment {
		height: 15px;
		font-size: 14px;
		font-weight: bold;
	}

	table.qabot tr.qarow td.qared {
		color: white;
		background-color: rgb(136, 0, 21);
	}

	table.qabot tr.qarow td.qagreen {
		color: white;
		background-color: rgb(0, 128, 64);
	}

	table.qabot tr.qarow td.qagray {
		color: black;
		background-color: rgb(128, 128, 128);
	}

	table.qabot tr.qarow td.qachart {
		width: 50%;
		text-align: left;
		vertical-align: top;
		border-bottom: 2px solid #ccc;
	}

	table.qabot tr.qarow td.qabuttons {
		height: 25px;
		margin-left: 5px;
		text-align: left;
		vertical-align: middle;
	}

	table.qabot tr.qarow td.qabuttons button {
		text-decoration: none;
	}
</style>

<!-- NavBar -->
<div class="mynavbar mysticky">
	<section class="row-fluid">	
		<div class="span12">
		    <%=nav3("Monotoring", "/monitoring", "Agency", "/monitoring", "Capacity")%>
		</div>
	</section>
</div>

<!-- Single Panel -->
<section class="row-fluid">
	<div class="span12 box">
        <table class="table table-condensed qabot">
            <%
            last_section = nil
            BlackStack::Monitoring.monitors.sort_by { |m| m.section_name }.each { |m|
              section = m.section_name
              color = m.pass? ? 'qagreen' : 'qared'
              value = m.last_value.to_s
              thres = m.get_threshold
              # if section changed
              if section.to_s != last_section
                %>
                <tr>
                  <td colspan=4>
                    <h3><%=section.to_s%></h3>
                  </td>
                </tr>
                <%
              end
              last_section = section
              %>
              <tr class='qarow'>
                <td class='qaname'>
                    <span class='qatitle'><%=m.name.encode_html%></span><br/>
                    <%=m.description.to_s%>
                </td>
                <td rowspan=1 class='qaflag <%=color%>'>
                    <%
                    if thres.to_i != 0
                    %>
                    <span class='qavalue'><%=value%> / <%=thres.to_s%></span>
                    <%
                    else # if thres.nil?
                    %>
                    <span class='qavalue'><%=value%></span>
                    <%
                    end # if thres.nil?
                    %>
                    <br/>
                    <span class='qacomment'><%=m.unit_name.encode_html%></span>
                </td>
              </tr>
              <%
            }
            %>
        </table>
    </div>
</div>
