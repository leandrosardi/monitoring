<%
return_message = {}
begin
    aid = params['id_account']
    period = params['period']
    a = BlackStack::MySaaS::Account.where(:id=>aid).first
    b = BlackStack::I2P::Account.where(:id=>aid).first
    c = BlackStack::Scraper::Account.where(:id=>aid).first
    d = BlackStack::Emails::Account.where(:id=>aid).first
    min_appending_rate = BlackStack::DfyLeads::Order::MIN_VERIFIED_RATE

    # Balance
    dt = b.deadline
    if dt
        dt = Time.parse(dt.to_s)
        days = ((dt-now).to_f / (24 * 60 * 60).to_f).to_i
        if days < 7
            color = 'orange'
        elsif days < 0
            color = 'red'
        else
            color = 'gray'
        end
        return_message[:deadline] = {}
        return_message[:deadline][:value] = "#{days} days"
        return_message[:deadline][:color] = color
    else
        return_message[:deadline] = {}
        return_message[:deadline][:value] = '-'
        return_message[:deadline][:color] = 'gray'
    end

    BlackStack::I2P::Account.update_balance_snapshot([b.id])

    balance = BlackStack::I2P::Balance.new(b.id, 'leads')
    return_message[:leads_credits] = {}
    return_message[:leads_credits][:value] = b.credits('leads').to_i.to_label
    return_message[:leads_credits][:color] = b.credits('leads').to_i > 0 ? 'blue' : 'red'

    balance = BlackStack::I2P::Balance.new(b.id, 'deliveries')
    return_message[:email_credits] = {}
    return_message[:email_credits][:value] = b.credits('deliveries').to_i.to_label
    return_message[:email_credits][:color] = b.credits('deliveries').to_i > 0 ? 'blue' : 'red'

    # Leads Scraping
    w = c.orders.size
    x = c.orders.select { |o| o.dfyl_id_parent.nil? && o.status && o.dfyl_stat_progress.to_i < 100 }.size
    y = c.orders.select { |o| o.dfyl_id_parent.nil? && o.status && o.dfyl_stat_progress.to_i >= 100 }.size
    z = c.orders.select { |o| o.dfyl_id_parent.nil? && !o.status }.size
    return_message[:active_orders] = {}
    if w == 0 # no orders at all
        return_message[:active_orders][:value] = "0"
        return_message[:active_orders][:color] = 'gray'
        return_message[:active_orders][:title] = 'no orders at all'
    elsif x > 0 # active and not-completed orders
        cnt = x
        avg = (c.orders.select { |o| o.dfyl_id_parent.nil? && o.status && o.dfyl_stat_progress.to_i < 100 }.map { |o| o.dfyl_stat_progress.to_i }.sum.to_f / x.to_f).to_i
        return_message[:active_orders][:value] = "#{cnt.to_label}"
        return_message[:active_orders][:color] = 'green'
        return_message[:active_orders][:title] = "orders in progress at #{avg}%"
        return_message[:active_orders][:label] = {}
        return_message[:active_orders][:label][:value] = "#{avg}%"
        return_message[:active_orders][:label][:color] = 'gray'
    elsif y > 0 # active and completed orders
        cnt = y
        avg = (c.orders.select { |o| o.dfyl_id_parent.nil? && o.status && o.dfyl_stat_progress.to_i >= 100 }.map { |o| o.dfyl_stat_progress.to_i }.sum.to_f / y.to_f).to_i
        return_message[:active_orders][:value] = "<i class='icon-ok'></i>"
        return_message[:active_orders][:color] = 'blue'
        return_message[:active_orders][:title] = 'orders completed'
        return_message[:active_orders][:label] = {}
        return_message[:active_orders][:label][:value] = "#{avg}%"
        return_message[:active_orders][:label][:color] = 'gray'
    elsif z > 0 # inactive orders
        cnt = z
        avg = (c.orders.select { |o| o.dfyl_id_parent.nil? && !o.status }.map { |o| o.dfyl_stat_progress.to_i }.sum.to_f / z.to_f).to_i
        return_message[:active_orders][:value] = "<i class='icon-off'></i>"
        return_message[:active_orders][:color] = 'red'
        return_message[:active_orders][:title] = 'orders paused'
        return_message[:active_orders][:label] = {}
        return_message[:active_orders][:label][:value] = "#{avg}%"
        return_message[:active_orders][:label][:color] = 'gray'
    end

    w = c.orders.select { |o| o.dfyl_id_parent.nil? && o.status && o.dfyl_stat_progress.to_i < 100 }
    x = w.size
    y = w.map { |o| o.dfyl_stat_verified_rate.to_f }.sum
    z = x > 0 ? (y.to_f / x.to_f).to_i : 0
    cnt = w.map { |o| o.dfyl_stat_leads_verified.to_i }.sum
    return_message[:average_verified_rate] = {}
    return_message[:average_verified_rate][:value] = cnt.to_label
    return_message[:average_verified_rate][:color] = cnt > 0 ? 'blue' : 'gray'
    return_message[:average_verified_rate][:title] = x > 0 ? "Found Verified Email of #{z}% of Leads Scraped" : 'no active orders'
    return_message[:average_verified_rate][:label] = {}
    return_message[:average_verified_rate][:label][:value] = x > 0 ? "#{z}%" : '-'
    if x > 0
        return_message[:average_verified_rate][:label][:color] = z < min_appending_rate ? 'red' : 'green'
    else
        return_message[:average_verified_rate][:label][:color] = 'gray'
    end
    
    # needed pages
    row = DB["select pages_per_day from v_dfyl_capacity_needed where id_account = '#{aid}'"].first
    x = row.nil? ? 0 : row[:pages_per_day].to_i 
    # uploaded pages
    y = 0 # total pages
    row = nil
    if period == 'today'
        row = DB["
            select 1 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and v.yy=extract('year', cast('#{now}' as timestamp)) 
            and v.mm=extract('month', cast('#{now}' as timestamp)) 
            and v.dd=extract('day', cast('#{now}' as timestamp))         
        "].first
    elsif period == 'yesterday'
        row = DB["
            select 1 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and v.yy=extract('year', cast('#{now}' as timestamp)-interval '1 day')
            and v.mm=extract('month', cast('#{now}' as timestamp)-interval '1 day') 
            and v.dd=extract('day', cast('#{now}' as timestamp)-interval '1 day')         
        "].first
    elsif period == 'last_24_hours'
        row = DB["
            select 1 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and cast(v.yy||'-'||v.mm||'-'||v.dd as timestamp) >= cast('#{now}' as timestamp)-interval '1 days'
        "].first
    elsif period == 'last_2_days'
        row = DB["
            select 1 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and cast(v.yy||'-'||v.mm||'-'||v.dd as timestamp) >= cast('#{now}' as timestamp)-interval '2 days'
        "].first
    elsif period == 'last_3_days'
        row = DB["
            select 3 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and cast(v.yy||'-'||v.mm||'-'||v.dd as timestamp) >= cast('#{now}' as timestamp)-interval '3 days'
        "].first
    elsif period == 'last_week'
        row = DB["
            select 7 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and cast(v.yy||'-'||v.mm||'-'||v.dd as timestamp) >= cast('#{now}' as timestamp)-interval '7 day'
        "].first
    elsif period == 'last_month'
        row = DB["
            select 30 as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and cast(v.yy||'-'||v.mm||'-'||v.dd as timestamp) >= cast('#{now}' as timestamp)-interval '1 month'
        "].first
    else #if period == 'month'
        row = DB["
            select extract('day', cast('#{now}' as timestamp)) as total_days, sum(total_pages) as total_pages
            from v_scraping_expenses_daily v 
            where v.id_account='#{aid}' 
            and v.yy=extract('year', cast('#{now}' as timestamp))
            and v.mm=extract('month', cast('#{now}' as timestamp)) 
        "].first
    end
    y = row[:total_pages].to_f / row[:total_days].to_f if row && row[:total_days].to_i > 0
    # 
    return_message[:daily_pages_needed] = {}
    return_message[:daily_pages_needed][:value] = x==0 ? '-' : x.to_label
    return_message[:daily_pages_needed][:color] = 'gray'
    return_message[:daily_pages_needed][:title] = "Daily Pages Needed to Meet Deadline, over the Pages Uploaded Daily in the #{period.to_s.gsub('_', ' ').capitalize}"
    return_message[:daily_pages_needed][:label] = {}
    return_message[:daily_pages_needed][:label][:value] = "#{'%.1f' % y}/d"
    return_message[:daily_pages_needed][:label][:color] = y > x ? 'green' : 'red'

    # Emails Deliveries
    w = d.campaigns.size
    x = d.campaigns.select { |o| o.status==1 && o.stat_left.to_i > 0 }.size
    y = d.campaigns.select { |o| o.status==1 && o.stat_left.to_i <= 0 }.size
    z = d.campaigns.select { |o| o.status!=1 }.size
    return_message[:active_campaigns] = {}
    if w == 0 # no campaigns at all
        return_message[:active_campaigns][:value] = "0"
        return_message[:active_campaigns][:color] = 'gray'
        return_message[:active_campaigns][:title] = 'no campaigns at all'
    elsif x > 0 # active and not-completed campaigns
        left = d.campaigns.select { |o| o.status==1 && o.stat_left.to_i > 0 }.map { |o| o.stat_left.to_i }.sum
        return_message[:active_campaigns][:value] = x.to_label
        return_message[:active_campaigns][:color] = 'green'
        return_message[:active_campaigns][:title] = 'campaigns in progress'
        return_message[:active_campaigns][:label] = {}
        return_message[:active_campaigns][:label][:value] = left.to_label
        return_message[:active_campaigns][:label][:color] = left > 0 ? 'green' : 'red'
    elsif y > 0 # active and completed campaigns
        left = 0
        return_message[:active_campaigns][:value] = "<i class='icon-ok'></i>"
        return_message[:active_campaigns][:color] = 'blue'
        return_message[:active_campaigns][:title] = 'campaigns completed'
        return_message[:active_campaigns][:label] = {}
        return_message[:active_campaigns][:label][:value] = left.to_label
        return_message[:active_campaigns][:label][:color] = left > 0 ? 'green' : 'red'
    elsif z > 0 # inactive campaigns
        left = d.campaigns.select { |o| o.status!=1}.map { |o| o.stat_left.to_i }.sum
        return_message[:active_campaigns][:value] = "<i class='icon-off'></i>"
        return_message[:active_campaigns][:color] = 'red'
        return_message[:active_campaigns][:title] = 'campaigns paused'
        return_message[:active_campaigns][:label] = {}
        return_message[:active_campaigns][:label][:value] = left.to_label
        return_message[:active_campaigns][:label][:color] = left > 0 ? 'green' : 'red'
    end

    q = "
    select sum(coalesce(t.stat_sents, 0)) as sents, sum(coalesce(t.stat_positive_replies, 0)) as prs
    from eml_timeline t 
    where t.id_account='#{aid}'    
    "
    if period == 'today'
        q += "
            and t.\"year\"=extract('year', cast('#{now}' as timestamp)) 
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)) 
            and t.\"day\"=extract('day', cast('#{now}' as timestamp))         
        "
    elsif period == 'yesterday'
        q += "
            and t.\"year\"=extract('year', cast('#{now}' as timestamp)-interval '1 day')
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)-interval '1 day') 
            and t.\"day\"=extract('day', cast('#{now}' as timestamp)-interval '1 day')         
        "
    elsif period == 'last_24_hours'
        q += "
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '1 days'
        "
    elsif period == 'last_2_days'
        q += "
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '2 days'
        "
    elsif period == 'last_3_days'
        q += "
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '3 days'
        "
    elsif period == 'last_week'
        q += "
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '7 day'
        "
    elsif period == 'last_month'
        q += "
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '1 month'
        "
    else #if period == 'month'
        q += "
            and t.\"year\"=extract('year', cast('#{now}' as timestamp))
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)) 
        "
    end
    row = DB[q].first
    sent = row[:sents].to_i
    pr = row[:prs].to_i
    avg = sent==0 ? 100.0 : (pr.to_f / sent.to_f) * 100.to_f
    return_message[:average_positive_responses_rate] = {}
    if sent == 0 && pr == 0
        return_message[:average_positive_responses_rate][:value] = "0/0"
        return_message[:average_positive_responses_rate][:color] = 'gray'
        return_message[:average_positive_responses_rate][:title] = 'no messages sent yet'
    elsif avg < 0.25 
        return_message[:average_positive_responses_rate][:color] = 'red'
        return_message[:average_positive_responses_rate][:value] = "#{pr.to_label}/#{sent.to_label}"
        return_message[:average_positive_responses_rate][:title] = 'low performance'

        return_message[:average_positive_responses_rate][:label] = {}
        return_message[:average_positive_responses_rate][:label][:value] = "#{'%.2f' % avg}%"
        return_message[:average_positive_responses_rate][:label][:color] = 'red'
    elsif avg >= 1.0
        return_message[:average_positive_responses_rate][:color] = 'green'
        return_message[:average_positive_responses_rate][:value] = "#{pr.to_label}/#{sent.to_label}"
        return_message[:average_positive_responses_rate][:title] = 'good performance'

        return_message[:average_positive_responses_rate][:label] = {}
        return_message[:average_positive_responses_rate][:label][:value] = "#{'%.2f' % avg}%"
        return_message[:average_positive_responses_rate][:label][:color] = 'green'
    else
        return_message[:average_positive_responses_rate][:color] = 'orange'
        return_message[:average_positive_responses_rate][:value] = "#{pr.to_label}/#{sent.to_label}"
        return_message[:average_positive_responses_rate][:title] = 'regular performance'

        return_message[:average_positive_responses_rate][:label] = {}
        return_message[:average_positive_responses_rate][:label][:value] = "#{'%.2f' % avg}%"
        return_message[:average_positive_responses_rate][:label][:color] = 'orange'
    end 

    # needed emails
    row = DB["select cast(sum(v.email_credits) as float)/15 as deliveries_per_day from v_eml_deadlines v where v.id_account = '#{aid}'"].first
    x = row.nil? ? 0 : row[:deliveries_per_day].to_i
    # delivered emails
    y = 0 # total pages
    row = nil
    if period == 'today'
        row = DB["
            select 1 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and t.\"year\"=extract('year', cast('#{now}' as timestamp)) 
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)) 
            and t.\"day\"=extract('day', cast('#{now}' as timestamp))         
        "].first
    elsif period == 'yesterday'
        row = DB["
            select 1 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and t.\"year\"=extract('year', cast('#{now}' as timestamp)-interval '1 day') 
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)-interval '1 day') 
            and t.\"day\"=extract('day', cast('#{now}' as timestamp)-interval '1 day')
        "].first
    elsif period == 'last_24_hours'
        row = DB["
            select 1 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '1 days'
        "].first
    elsif period == 'last_2_days'
        row = DB["
            select 2 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '2 days'
        "].first
    elsif period == 'last_3_days'
        row = DB["
            select 3 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '3 days'
        "].first
    elsif period == 'last_week'
        row = DB["
            select 7 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '7 day'
        "].first
    elsif period == 'last_month'
        row = DB["
            select 30 as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and cast(t.\"year\"||'-'||t.\"month\"||'-'||t.\"day\" as timestamp) >= cast('#{now}' as timestamp)-interval '1 month'
        "].first
    elsif period == 'month'
        row = DB["
            select extract('day', cast('#{now}' as timestamp)) as total_days, sum(coalesce(t.stat_sents, 0)) as total_sents
            from eml_timeline t 
            where t.id_account='#{aid}'    
            and t.\"year\"=extract('year', cast('#{now}' as timestamp)-interval '1 day') 
            and t.\"month\"=extract('month', cast('#{now}' as timestamp)-interval '1 day') 
        "].first
    end
    y = row[:total_sents].to_f / row[:total_days].to_f if row && row[:total_days].to_i > 0
    # 
    return_message[:daily_deliveries_needed] = {}
    return_message[:daily_deliveries_needed][:value] = x==0 ? '-' : x.to_label
    return_message[:daily_deliveries_needed][:color] = 'gray'
    return_message[:daily_deliveries_needed][:title] = "Daily Deliveries Needed to Meet Deadline, over the Deliveries Sent Daily in the #{period.to_s.gsub('_', ' ').capitalize}"
    return_message[:daily_deliveries_needed][:label] = {}
    return_message[:daily_deliveries_needed][:label][:value] = "#{'%.1f' % y}/d"
    return_message[:daily_deliveries_needed][:label][:color] = y > x ? 'green' : 'red'


    # return
    return_message[:status] = 'success'
rescue => e
    return_message[:status] = e.to_console
end
return return_message.to_json
%>